import { removeCodeRanges } from 'twoslash-protocol';

const defaultCompilerOptions = {
  strict: true,
  module: 99,
  target: 99,
  allowJs: true,
  skipDefaultLibCheck: true,
  skipLibCheck: true,
  moduleDetection: 3
};
const defaultHandbookOptions = {
  errors: [],
  noErrors: false,
  noErrorsCutted: false,
  noErrorValidation: false,
  noStaticSemanticInfo: false,
  showEmit: false,
  showEmittedFile: void 0,
  keepNotations: false
};

class TwoslashError extends Error {
  title;
  description;
  recommendation;
  code;
  constructor(title, description, recommendation, code) {
    let message = `
## ${title}

${description}
`;
    if (recommendation)
      message += `
${recommendation}`;
    if (code)
      message += `
${code}`;
    super(message);
    this.title = title;
    this.description = description;
    this.recommendation = recommendation;
    this.code = code;
  }
}

function serialize(o){return typeof o=="string"?`'${o}'`:new c().serialize(o)}const c=/*@__PURE__*/function(){class o{#t=new Map;compare(t,r){const e=typeof t,n=typeof r;return e==="string"&&n==="string"?t.localeCompare(r):e==="number"&&n==="number"?t-r:String.prototype.localeCompare.call(this.serialize(t,true),this.serialize(r,true))}serialize(t,r){if(t===null)return "null";switch(typeof t){case "string":return r?t:`'${t}'`;case "bigint":return `${t}n`;case "object":return this.$object(t);case "function":return this.$function(t)}return String(t)}serializeObject(t){const r=Object.prototype.toString.call(t);if(r!=="[object Object]")return this.serializeBuiltInType(r.length<10?`unknown:${r}`:r.slice(8,-1),t);const e=t.constructor,n=e===Object||e===void 0?"":e.name;if(n!==""&&globalThis[n]===e)return this.serializeBuiltInType(n,t);if(typeof t.toJSON=="function"){const i=t.toJSON();return n+(i!==null&&typeof i=="object"?this.$object(i):`(${this.serialize(i)})`)}return this.serializeObjectEntries(n,Object.entries(t))}serializeBuiltInType(t,r){const e=this["$"+t];if(e)return e.call(this,r);if(typeof r?.entries=="function")return this.serializeObjectEntries(t,r.entries());throw new Error(`Cannot serialize ${t}`)}serializeObjectEntries(t,r){const e=Array.from(r).sort((i,a)=>this.compare(i[0],a[0]));let n=`${t}{`;for(let i=0;i<e.length;i++){const[a,l]=e[i];n+=`${this.serialize(a,true)}:${this.serialize(l)}`,i<e.length-1&&(n+=",");}return n+"}"}$object(t){let r=this.#t.get(t);return r===void 0&&(this.#t.set(t,`#${this.#t.size}`),r=this.serializeObject(t),this.#t.set(t,r)),r}$function(t){const r=Function.prototype.toString.call(t);return r.slice(-15)==="[native code] }"?`${t.name||""}()[native]`:`${t.name}(${t.length})${r.replace(/\s*\n\s*/g,"")}`}$Array(t){let r="[";for(let e=0;e<t.length;e++)r+=this.serialize(t[e]),e<t.length-1&&(r+=",");return r+"]"}$Date(t){try{return `Date(${t.toISOString()})`}catch{return "Date(null)"}}$ArrayBuffer(t){return `ArrayBuffer[${new Uint8Array(t).join(",")}]`}$Set(t){return `Set${this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)))}`}$Map(t){return this.serializeObjectEntries("Map",t.entries())}}for(const s of ["Error","RegExp","URL"])o.prototype["$"+s]=function(t){return `${s}(${t})`};for(const s of ["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join(",")}]`};for(const s of ["BigInt64Array","BigUint64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join("n,")}${t.length>0?"n":""}]`};return o}();

const z=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],R=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",r=[];class k{_data=new l;_hash=new l([...z]);_nDataBytes=0;_minBufferSize=0;finalize(e){e&&this._append(e);const s=this._nDataBytes*8,t=this._data.sigBytes*8;return this._data.words[t>>>5]|=128<<24-t%32,this._data.words[(t+64>>>9<<4)+14]=Math.floor(s/4294967296),this._data.words[(t+64>>>9<<4)+15]=s,this._data.sigBytes=this._data.words.length*4,this._process(),this._hash}_doProcessBlock(e,s){const t=this._hash.words;let i=t[0],o=t[1],a=t[2],c=t[3],h=t[4],g=t[5],f=t[6],y=t[7];for(let n=0;n<64;n++){if(n<16)r[n]=e[s+n]|0;else {const d=r[n-15],j=(d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3,B=r[n-2],x=(B<<15|B>>>17)^(B<<13|B>>>19)^B>>>10;r[n]=j+r[n-7]+x+r[n-16];}const m=h&g^~h&f,p=i&o^i&a^o&a,u=(i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22),b=(h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25),w=y+b+m+R[n]+r[n],M=u+p;y=f,f=g,g=h,h=c+w|0,c=a,a=o,o=i,i=w+M|0;}t[0]=t[0]+i|0,t[1]=t[1]+o|0,t[2]=t[2]+a|0,t[3]=t[3]+c|0,t[4]=t[4]+h|0,t[5]=t[5]+g|0,t[6]=t[6]+f|0,t[7]=t[7]+y|0;}_append(e){typeof e=="string"&&(e=l.fromUtf8(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes;}_process(e){let s,t=this._data.sigBytes/64;e?t=Math.ceil(t):t=Math.max((t|0)-this._minBufferSize,0);const i=t*16,o=Math.min(i*4,this._data.sigBytes);if(i){for(let a=0;a<i;a+=16)this._doProcessBlock(this._data.words,a);s=this._data.words.splice(0,i),this._data.sigBytes-=o;}return new l(s,o)}}class l{words;sigBytes;constructor(e,s){e=this.words=e||[],this.sigBytes=s===void 0?e.length*4:s;}static fromUtf8(e){const s=unescape(encodeURIComponent(e)),t=s.length,i=[];for(let o=0;o<t;o++)i[o>>>2]|=(s.charCodeAt(o)&255)<<24-o%4*8;return new l(i,t)}toBase64(){const e=[];for(let s=0;s<this.sigBytes;s+=3){const t=this.words[s>>>2]>>>24-s%4*8&255,i=this.words[s+1>>>2]>>>24-(s+1)%4*8&255,o=this.words[s+2>>>2]>>>24-(s+2)%4*8&255,a=t<<16|i<<8|o;for(let c=0;c<4&&s*8+c*6<this.sigBytes*8;c++)e.push(S.charAt(a>>>6*(3-c)&63));}return e.join("")}concat(e){if(this.words[this.sigBytes>>>2]&=4294967295<<32-this.sigBytes%4*8,this.words.length=Math.ceil(this.sigBytes/4),this.sigBytes%4)for(let s=0;s<e.sigBytes;s++){const t=e.words[s>>>2]>>>24-s%4*8&255;this.words[this.sigBytes+s>>>2]|=t<<24-(this.sigBytes+s)%4*8;}else for(let s=0;s<e.sigBytes;s+=4)this.words[this.sigBytes+s>>>2]=e.words[s>>>2];this.sigBytes+=e.sigBytes;}}function digest(_){return new k().finalize(_).toBase64()}

function hash(input) {
  return digest(serialize(input));
}

const reConfigBoolean = /^\/\/\s?@(\w+)$/gm;
const reConfigValue = /^\/\/\s?@(\w+):\s?(.+)$/gm;
const reAnnonateMarkers = /^\s*\/\/\s*\^(\?|\||\^+)( .*)?$/gm;
const reCutBefore = /^\/\/\s?---cut(-before)?---$/;
const reCutAfter = /^\/\/\s?---cut-after---$/;
const reCutStart = /^\/\/\s?---cut-start---$/;
const reCutEnd = /^\/\/\s?---cut-end---$/;
const reFilenamesMakers = /^[\t\v\f ]*\/\/\s?@filename: (.+)$/gm;

function getObjectHash(obj) {
  return hash(obj);
}
function parsePrimitive(value, type) {
  if (typeof value === type)
    return value;
  switch (type) {
    case "number":
      return +value;
    case "string":
      return value;
    case "boolean":
      return value.toLowerCase() === "true" || value.length === 0;
  }
  throw new TwoslashError(
    `Unknown primitive value in compiler flag`,
    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,
    `This is likely a typo.`
  );
}
function typesToExtension(types) {
  const map = {
    js: "js",
    javascript: "js",
    ts: "ts",
    typescript: "ts",
    tsx: "tsx",
    jsx: "jsx",
    json: "json",
    jsn: "json",
    map: "json",
    mts: "ts",
    cts: "ts",
    mjs: "js",
    cjs: "js"
  };
  if (map[types])
    return map[types];
  throw new TwoslashError(
    `Unknown TypeScript extension given to Twoslash`,
    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,
    ``
  );
}
function getIdentifierTextSpans(ts, sourceFile, fileOffset) {
  const textSpans = [];
  checkChildren(sourceFile);
  return textSpans;
  function checkChildren(node) {
    ts.forEachChild(node, (child) => {
      if (ts.isIdentifier(child)) {
        const text = child.getText(sourceFile);
        const start = child.getStart(sourceFile, false) + fileOffset;
        const end = start + text.length;
        textSpans.push([start, end, text]);
      }
      checkChildren(child);
    });
  }
}
function getOptionValueFromMap(name, key, optMap) {
  const result = optMap.get(key.toLowerCase());
  if (result === void 0) {
    const keys = Array.from(optMap.keys());
    throw new TwoslashError(
      `Invalid inline compiler value`,
      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,
      `Allowed values: ${keys.join(",")}`
    );
  }
  return result;
}
function splitFiles(code, defaultFileName, root) {
  const matches = Array.from(code.matchAll(reFilenamesMakers));
  const allFilenames = matches.map((match) => match[1].trimEnd());
  let currentFileName = allFilenames.includes(defaultFileName) ? "__index__.ts" : defaultFileName;
  const files = [];
  let index = 0;
  for (const match of matches) {
    const offset = match.index;
    const content = code.slice(index, offset);
    if (content) {
      files.push({
        offset: index,
        filename: currentFileName,
        filepath: root + currentFileName,
        content,
        extension: getExtension(currentFileName)
      });
    }
    currentFileName = match[1].trimEnd();
    index = offset;
  }
  if (index < code.length) {
    const content = code.slice(index);
    files.push({
      offset: index,
      filename: currentFileName,
      filepath: root + currentFileName,
      content,
      extension: getExtension(currentFileName)
    });
  }
  return files;
}
function getExtension(fileName) {
  return fileName.split(".").pop();
}
function parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {
  if (customTags.includes(name)) {
    return {
      type: "tag",
      name,
      value,
      start,
      end
    };
  }
  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());
  if (compilerDecl) {
    switch (compilerDecl.type) {
      case "number":
      case "string":
      case "boolean":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: parsePrimitive(value, compilerDecl.type),
          start,
          end
        };
      case "list": {
        const elementType = compilerDecl.element.type;
        const strings = value.split(",");
        const resolved = typeof elementType === "string" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: resolved,
          start,
          end
        };
      }
      case "object":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: JSON.parse(value),
          start,
          end
        };
      default: {
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),
          start,
          end
        };
      }
    }
  }
  if (Object.keys(defaultHandbookOptions).includes(name)) {
    if (name === "errors" && typeof value === "string")
      value = value.split(" ").map(Number);
    if (name === "noErrors" && typeof value === "string") {
      if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      else
        value = value.split(" ").map(Number);
    }
    return {
      type: "handbookOptions",
      name,
      value,
      start,
      end
    };
  }
  return {
    type: "unknown",
    name,
    value,
    start,
    end
  };
}
function findFlagNotations(code, customTags, tsOptionDeclarations) {
  const flagNotations = [];
  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {
    const index = match.index;
    const name = match[1];
    flagNotations.push(
      parseFlag(name, true, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  Array.from(code.matchAll(reConfigValue)).forEach((match) => {
    const name = match[1];
    if (name === "filename")
      return;
    const index = match.index;
    const value = match[2];
    flagNotations.push(
      parseFlag(name, value, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  return flagNotations;
}
function findCutNotations(code, meta) {
  let removals = [];
  const lines = code.split("\n");
  const cutStarts = [];
  let idx = 0;
  let lineIndex = 0;
  for (const line of lines) {
    const comment = line.trim();
    if (comment.match(reCutBefore)) {
      removals = [[0, idx + line.length + 1]];
    } else if (comment.match(reCutAfter)) {
      removals.push([idx, code.length]);
      break;
    } else if (comment.match(reCutStart)) {
      cutStarts.push(idx);
    } else if (comment.match(reCutEnd)) {
      const startIdx = cutStarts.pop();
      if (startIdx === void 0) {
        const startLine = lines.findIndex((line2, i) => i > lineIndex && line2.trim().match(reCutStart));
        if (startLine === -1) {
          throw new TwoslashError(
            `Mismatched cut markers`,
            `You have an unclosed the cut-end at line ${lineIndex + 1}`,
            `Make sure you have a matching pair for each.`
          );
        }
        throw new TwoslashError(
          `Mismatched cut markers`,
          `You have a cut-start at line ${startLine + 1} which is after the cut-end at line ${lineIndex + 1}`,
          `Make sure you have a matching pair for each.`
        );
      }
      removals.push([startIdx, idx + line.length + 1]);
    }
    lineIndex++;
    idx += line.length + 1;
  }
  if (cutStarts.length > 0) {
    throw new TwoslashError(
      `Mismatched cut markers`,
      `You have unclosed cut-starts at lines ${cutStarts.join(", ")}`,
      `Make sure you have a matching pair for each.`
    );
  }
  if (meta)
    meta.removals.push(...removals);
  return removals;
}
function findQueryMarkers(code, meta, pc) {
  if (code.includes("//")) {
    const linesQuery = /* @__PURE__ */ new Set();
    Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {
      const type = match[1];
      const index = match.index;
      meta.removals.push([index, index + match[0].length + 1]);
      const markerIndex = match[0].indexOf("^");
      const pos = pc.indexToPos(index + markerIndex);
      let targetLine = pos.line - 1;
      while (linesQuery.has(targetLine) && targetLine >= 0)
        targetLine -= 1;
      const targetIndex = pc.posToIndex(targetLine, pos.character);
      if (type === "?") {
        meta.positionQueries.push(targetIndex);
      } else if (type === "|") {
        meta.positionCompletions.push(targetIndex);
      } else {
        const markerLength = match[0].lastIndexOf("^") - markerIndex + 1;
        meta.positionHighlights.push([
          targetIndex,
          targetIndex + markerLength,
          match[2]?.trim()
        ]);
      }
      linesQuery.add(pos.line);
    });
  }
  return meta;
}
function removeTsExtension(filename) {
  const sansMapOrDTS = filename.replace(/\.map$/, "").replace(/\.d\.ts$/, ".ts").replace(/\.map$/, "");
  return sansMapOrDTS.replace(/\.[^/.]+$/, "");
}

const flagKeys = [
  "all",
  "allowArbitraryExtensions",
  "allowImportingTsExtensions",
  "allowJs",
  "allowSyntheticDefaultImports",
  "allowUmdGlobalAccess",
  "allowUnreachableCode",
  "allowUnusedLabels",
  "alwaysStrict",
  "assumeChangesOnlyAffectDirectDependencies",
  "baseUrl",
  "build",
  "charset",
  "checkJs",
  "composite",
  "customConditions",
  "declaration",
  "declarationDir",
  "declarationMap",
  "diagnostics",
  "disableReferencedProjectLoad",
  "disableSizeLimit",
  "disableSolutionSearching",
  "disableSourceOfProjectReferenceRedirect",
  "downlevelIteration",
  "emitBOM",
  "emitDeclarationOnly",
  "emitDecoratorMetadata",
  "errors",
  "esModuleInterop",
  "exactOptionalPropertyTypes",
  "experimentalDecorators",
  "explainFiles",
  "extendedDiagnostics",
  "forceConsistentCasingInFileNames",
  "generateCpuProfile",
  "generateTrace",
  "help",
  "help",
  "ignoreDeprecations",
  "importHelpers",
  "importsNotUsedAsValues",
  "incremental",
  "init",
  "inlineSourceMap",
  "inlineSources",
  "isolatedModules",
  "jsx",
  "jsxFactory",
  "jsxFragmentFactory",
  "jsxImportSource",
  "keepNotations",
  "keyofStringsOnly",
  "lib",
  "listEmittedFiles",
  "listFiles",
  "listFilesOnly",
  "locale",
  "mapRoot",
  "maxNodeModuleJsDepth",
  "module",
  "moduleDetection",
  "moduleResolution",
  "moduleSuffixes",
  "newLine",
  "noEmit",
  "noEmitHelpers",
  "noEmitOnError",
  "noErrorTruncation",
  "noErrorValidation",
  "noErrors",
  "noErrorsCutted",
  "noFallthroughCasesInSwitch",
  "noImplicitAny",
  "noImplicitOverride",
  "noImplicitReturns",
  "noImplicitThis",
  "noImplicitUseStrict",
  "noLib",
  "noPropertyAccessFromIndexSignature",
  "noResolve",
  "noStaticSemanticInfo",
  "noStrictGenericChecks",
  "noUncheckedIndexedAccess",
  "noUnusedLocals",
  "noUnusedParameters",
  "out",
  "outDir",
  "outFile",
  "paths",
  "plugins",
  "preserveConstEnums",
  "preserveSymlinks",
  "preserveValueImports",
  "preserveWatchOutput",
  "pretty",
  "project",
  "reactNamespace",
  "removeComments",
  "resolveJsonModule",
  "resolvePackageJsonExports",
  "resolvePackageJsonImports",
  "rootDir",
  "rootDirs",
  "showConfig",
  "showEmit",
  "showEmittedFile",
  "skipDefaultLibCheck",
  "skipLibCheck",
  "sourceMap",
  "sourceRoot",
  "strict",
  "strictBindCallApply",
  "strictFunctionTypes",
  "strictNullChecks",
  "strictPropertyInitialization",
  "stripInternal",
  "suppressExcessPropertyErrors",
  "suppressImplicitAnyIndexErrors",
  "target",
  "traceResolution",
  "tsBuildInfoFile",
  "typeRoots",
  "types",
  "useDefineForClassFields",
  "useUnknownInCatchVariables",
  "verbatimModuleSyntax",
  "version",
  "watch"
];

function removeTwoslashNotations(code, customTags) {
  const meta = {
    removals: []
  };
  const tags = [
    ...customTags ?? [],
    ...flagKeys
  ];
  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  Array.from(code.matchAll(reConfigValue)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  findCutNotations(code, meta);
  Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {
    const index = match.index;
    meta.removals.push([index, index + match[0].length + 1]);
  });
  return removeCodeRanges(code, meta.removals).code;
}

export { TwoslashError as T, findFlagNotations as a, findQueryMarkers as b, defaultHandbookOptions as c, defaultCompilerOptions as d, removeTsExtension as e, findCutNotations as f, getObjectHash as g, getExtension as h, getIdentifierTextSpans as i, removeTwoslashNotations as r, splitFiles as s, typesToExtension as t };
